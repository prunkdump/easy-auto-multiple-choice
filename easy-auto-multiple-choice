#! /usr/bin/perl -CS 
use strict;
use warnings;

# script encoding 
use utf8;

# stdout encoding #
#binmode(STDOUT, ":utf8");
# useless with -CS option #
use File::Spec;
use Cwd;
use Text::CSV qw( csv );; 
use Unicode::Normalize;
use File::Copy qw/ copy /;

######################
# localized contants #
######################
my $defaultTestTXTFileName = "sujet";
my $testFileName = "sujet";
my $resultFileName = "resultats.csv";
my $detailledResultFileName = "resultats_complet.csv";
my $resultFileSeparator = ";";
my $scanDirectoryName = "scans";

# translations for "name", "firstname" or "group" #
# must be lower case and without accents #
my %studentCSVFieldsNames = ( "name" => "name",
                              "lastname" => "name",
                              "surname" => "name",
                              "students" => "name",
                              "nom" => "name",
                              "nom de famille" => "name",
                              "eleve" => "name",
                              "firstname" => "firstname",
                              "first name" => "firstname",
                              "givenname" => "firstname",
                              "given name" => "firstname",
                              "prenom" => "firstname",
                              "group" => "group",
                              "class" => "group",
                              "groupe" => "group",
                              "classe" => "group");


##################################
# files generated by each action #
##################################
my $amcPrivateDir = "amc";
my $inputCSVFileName = "inputlist.csv";
my $baseTestTEXFileName = "test_base.tex";
my $baseTestPDFFileName = "test_base.pdf";
my $testTEXFileName = "test.tex";
my $scanFilesListName = "scan_files_list.txt";
my $testResultsFileName = "results.csv";

my %actionFiles = ( "gui"          => ["test"],
                    "set-students" => ["$amcPrivateDir/$inputCSVFileName"],
                    "edit-test"    => [],
                    "build-test"   => ["$amcPrivateDir/$baseTestTEXFileName",
                                       "$amcPrivateDir/$baseTestPDFFileName",
                                       "$amcPrivateDir/$testTEXFileName",
                                       "$amcPrivateDir/data/layout.sqlite",
                                       "$amcPrivateDir/DOC-sujet.pdf",
                                       "$amcPrivateDir/DOC-catalog.pdf",
                                       "$amcPrivateDir/DOC-calage.xy",
                                       "$amcPrivateDir/DOC-corrige.pdf",
                                       "$amcPrivateDir/DOC-indiv-solution.pdf",
                                       "$amcPrivateDir/amc-compiled.log",
                                       "$amcPrivateDir/amc-compiled.aux",
                                       "$amcPrivateDir/amc-compiled.amc",
                                       "$amcPrivateDir/amc-compiled.cs",
                                       "${testFileName}.pdf",
                                       "$amcPrivateDir/data/capture.sqlite"],
                    "read-copies"  => ["$amcPrivateDir/$scanFilesListName",
                                       "$amcPrivateDir/amc-compiled.xy",
                                       "$amcPrivateDir/amc-compiled.pdf",
                                       "$amcPrivateDir/data/scoring.sqlite",
                                       "$amcPrivateDir/data/association.sqlite",
                                       "$amcPrivateDir/exports/$testResultsFileName",
                                       "$resultFileName",
                                       "$detailledResultFileName"],
                    "clean"        => [] ); 


sub cleanActionFiles {

   my ($projectPath,$action) = (@_);
   if( exists($actionFiles{$action}) ) {
      foreach my $actionFilePath (@{$actionFiles{$action}}) {
         if( -f "$projectPath/$actionFilePath" ) {
            unlink("$projectPath/$actionFilePath");
         }
      }
   }
}

sub cleanAllActionFiles {

   my ($projectPath) = (@_);
   foreach my $action (keys(%actionFiles)) {
      cleanActionFiles($projectPath, $action);
   }
}


sub createAmcBaseDirs {

   my $projectPath = $_[0];

   if( -d $projectPath ) {
      print("Creating base project files...   ");
      foreach my $dirPath ("$projectPath/$amcPrivateDir",
                           "$projectPath/$amcPrivateDir/cr",
                           "$projectPath/$amcPrivateDir/cr/corrections",
                           "$projectPath/$amcPrivateDir/cr/corrections/jpg",
                           "$projectPath/$amcPrivateDir/cr/corrections/pdf",
                           "$projectPath/$amcPrivateDir/cr/zooms",
                           "$projectPath/$amcPrivateDir/cr/diagnostic",
                           "$projectPath/$amcPrivateDir/data",
                           "$projectPath/$amcPrivateDir/scans",
                           "$projectPath/$amcPrivateDir/exports") {
         if( ! -e $dirPath ) {
            mkdir($dirPath);
         }
      }
      print("Done.\n");
   }
}


#############
# error log #
# for csv   #
#############
my $localErrorMessage = '';
my $localErrorCode = 0;
sub errorHandler {
   $localErrorMessage = $_[0];
   if( $localErrorMessage =~ m/ERROR: (\d{4})/ ) {
      $localErrorCode = scalar($1);
   } else {
      $localErrorCode = 0;
   }
}


########################
# string normalization #
########################
sub normalizeString {

   my $unicodeString = $_[0];
   chomp($unicodeString);

   # remove BOM #
   $unicodeString =~ s/^\x{FEFF}//;

   # remove special characters #
   $unicodeString = NFKD($unicodeString);
   $unicodeString =~ s/\p{NonspacingMark}//g;

   # trim and lowercase
   $unicodeString = lc($unicodeString);
   $unicodeString =~ s/^\s+|\s+$//g;

   return $unicodeString;
}



###################
# parse arguments #
###################
# get : 
# $workingPath
# $action

sub usage {
   my $binName = (File::Spec->splitpath($0))[2];
   print("usage : $binName <working_path> <action>\n");
   print("Possible actions are :\n");
   print("   gui          : launch the GUI\n");
   print("   set-students : read student list from CSV file\n");
   print("   edit-test    : launch the test editor\n");
   print("   build-test   : build a printable test\n");
   print("   read-copies  : read copies from scans\n");
   print("   clean        : clean all files except test source and student list\n");
   exit(0);
}    


# need just two arguments the path and the action #
if ( @ARGV !=  2 ) {
   usage();
}

# check path #
my $workingPath = $ARGV[0];
$workingPath = Cwd::realpath($workingPath);
if( ! -d $workingPath ) {
   print("Cannot find working directory : $workingPath\n");
   usage();
}

# check action #
my $action = $ARGV[1];
if( ! exists($actionFiles{$action}) ) {
   print("Unknown action : $action \n");
   usage();
}

# init working dir #
createAmcBaseDirs($workingPath);


#########################
# ACTION : set-students #
#########################
sub setStudents {

   #-------#
   # clean #
   #-------#
   cleanActionFiles("$workingPath","set-students");

   # search for a csv file witch is not the exam result #
   my @csvFiles = glob("$workingPath/*.csv");
   push(@csvFiles, glob("$workingPath/*.CSV"));
   @csvFiles = grep(!/($resultFileName|$detailledResultFileName)$/, @csvFiles);


   # we need only one file #
   if( @csvFiles == 0 ) {
      print("No csv student list file found in the working directory !\n");
      print("Please ensure there is a csv file containing the list of students in :\n");
      print("$workingPath\n");
      exit(0);
   } 

   if( @csvFiles > 1 ) {
      print("Multiple csv files found for students list !\n");
      print("Please keep only the correct one and delete the others :\n");
      foreach my $csvFile (@csvFiles) {
         print("$csvFile\n");
      }
      exit(0);
   }

   my $studentsCSVPath = $csvFiles[0];


   #---------------------------#
   # try to parse the CSV file #
   #---------------------------#

   # create csv object #
   my $csv = Text::CSV->new({ binary => 1, auto_diag => 1});

   # open file #
   my $studentsCSVHandle;
   open($studentsCSVHandle, '<:encoding(UTF-8)', $studentsCSVPath)
      or die "Could not open file '$studentsCSVPath' $!";

   # read first line and try to determine CSV parameters #
   $SIG{__WARN__} = \&errorHandler;
   eval { $csv->header($studentsCSVHandle); };
   $SIG{__WARN__} = 'DEFAULT';


   # on error try to correct #
   if ( $@ ) {
      
      if( $localErrorCode == 1012 ) {

         # the header contain some empty fields, put some generic names #
         # ! this may be not a header line ! #
         my $studentsCSVSep = $csv->sep_char;

         seek($studentsCSVHandle, 0, 0);

         my $studentsCSVHeader = <$studentsCSVHandle>;
         my @studentsCSVHeaderNames = split(/$studentsCSVSep/,$studentsCSVHeader);
         
         my $headerIncrement = 0;
         my @modifiedHeader;
         foreach my $headerName (@studentsCSVHeaderNames) {
            if( $headerName ) {
               push @modifiedHeader, $headerName;
            } else {
               push @modifiedHeader, "generatedHeaderName" . $headerIncrement;
               $headerIncrement++;
            }
         }

         $csv = Text::CSV->new({ binary => 1, auto_diag => 1, sep_char => $studentsCSVSep });
         $csv->column_names(@modifiedHeader);
      }

      elsif( $localErrorCode == 1013 ) {

         # some headers are equal, may be no header line, the header is set later #
         my $studentsCSVSep = $csv->sep_char;
         $csv = Text::CSV->new({ binary => 1, auto_diag => 1, sep_char => $studentsCSVSep });
      }

      # unknown error #
      else {
         print("Error while parsing student CSV file !\n");
         print("$localErrorMessage\n");
         exit(0);
      }
   }

   #---------------------#
   # try to find headers #
   #---------------------#
   my $idColumnFound;
   
   # if we have headers check them #
   # ! this may be the first entry and not the header line ! #
   if( $csv->column_names ) {

      # translate header names #
      my @newHeaderNames;
      
      foreach my $headerName ($csv->column_names) {

         my $normalizedHeaderName = normalizeString($headerName);

         if( exists($studentCSVFieldsNames{$normalizedHeaderName}) ) {
            push @newHeaderNames, $studentCSVFieldsNames{$normalizedHeaderName};
            if( $studentCSVFieldsNames{$normalizedHeaderName} ne "group" ) { #name or firstname 
               $idColumnFound = "true";
            }
         } else {
            push @newHeaderNames, $headerName;
         }
      }

      $csv->column_names(@newHeaderNames);
   }


   # if we don't have correct header names, maybe this file have no header #
   # check a line #
   if( ! $idColumnFound ) {

      # go to beginning #
      seek($studentsCSVHandle, 0, 0);

      # get the first line #
      my $csvLine = <$studentsCSVHandle>;
      my @csvLineFields = split(/$csv->sep_char/,$csvLine);

      # assume one field is the complete name #
      if( @csvLineFields == 1 ) {
         $csv->column_names(["name"]);
      } 

      # assume two fields is name and firstname #
      # or firstname and name #  
      elsif( @csvLineFields == 2 ) {
         $csv->column_names(["name","firstname"]);
      } 

      # assume three fields is name, firstname and group #
      elsif( @csvLineFields == 3 ) {
         $csv->column_names(["name","firstname","group"]);
      }

      # cannot read CSV #
      else {
         print("Error while parsing students CSV file :\n");
         print("$studentsCSVPath\n");
         print("Please add headers to the CSV file\n");
         print("or keep only one or two fiedls for the student name.\n");
         exit(0);
      }

      # there is no header #
      seek($studentsCSVHandle, 0, 0);
   }

   # finish to parse #
   my $studentList = $csv->getline_hr_all($studentsCSVHandle);
   close($studentsCSVHandle);


   #-------------------------------------#
   # gererate the input list of students #
   # and display list of groups          #
   #-------------------------------------#
   my %studentGroups = ();

   # open file #
   open(my $inputCSVFileHandle, '>:encoding(UTF-8)', "$workingPath/$amcPrivateDir/$inputCSVFileName")
      or die "Could not open file '$workingPath/$amcPrivateDir/$inputCSVFileName' $!";

   # write header #
   print $inputCSVFileHandle "id,name,givenname,displayname,group\n";

   # write lines #
   my $currentId = 1; 
   foreach my $student (@$studentList) {

      # generate display name  #
      my $studentName = '';
      my $studentGivenName = '';
      my $studentDisplayName = '';
      my $studentGroup = '';

      if( exists($student->{name}) ) {
         $studentName = "$student->{name}";
         $studentDisplayName .= "$studentName ";
      }

      if( exists($student->{firstname}) ) {
         $studentGivenName = "$student->{firstname}";         
         $studentDisplayName .= "$studentGivenName ";
      }

      if( exists($student->{group}) ) {
         $studentGroup = "$student->{group}";
         $studentDisplayName .= "$studentGroup ";
      }
      $studentDisplayName =~ s/ $//;

      # check group #
      if( exists($student->{group}) ) {
         if( ! exists($studentGroups{$studentGroup}) ) {
            $studentGroups{$studentGroup} = "true";
         }
      }

      # write entry #
      print $inputCSVFileHandle "$currentId,$studentName,$studentGivenName,$studentDisplayName,$studentGroup\n";
      $currentId++;
   }

   close($inputCSVFileHandle);
   $currentId--;

   # done #
   print("Found $currentId students in the csv file :\n");
   print("$studentsCSVPath\n");

   # if we have groups, display them #
   my @studentGroupList = keys(%studentGroups);
   if( @studentGroupList ) {
      print("From the following groups :\n");
      foreach my $group (@studentGroupList) {
         print("$group\n");
      }
      print("\n");
   }

   # next #
   print("You can now use the \"edit-test\" or \"build-test\" action\n");
   print("to create a test for these students.\n"); 
}


# ensure the set-student step was done #
sub ensureSetStudents {

   if( ! -f "$workingPath/$amcPrivateDir/$inputCSVFileName" ) {
      print("Please generate a student list before !\n");
      print("Put a csv file containing the list of students \n");
      print("in the working directory :\n");
      print("$workingPath\n");
      print("And launch the \"set-students\" actions\n");
      return;
   }

   return "true";
}


#######################
# ACTION : edit-test  #
#######################

sub searchOrCreateTXTTest {

   my $testSourceFile;

   # try to find a txt file #
   my @txtFiles = glob("$workingPath/*.txt");
   push(@txtFiles, glob("$workingPath/*.TXT"));

   # if multiple found, warn #
   if( @txtFiles > 1 ) {
      print("Multiple TXT files found for test source !\n");
      print("Please keep only the correct one and delete the others :\n");
      foreach my $txtFile (@txtFiles) {
         print("$txtFile\n");
      }
      exit(0);
   }

   # if no txt file, generate one # 
   elsif( @txtFiles == 0 ) {

      $testSourceFile = "$workingPath/${defaultTestTXTFileName}.txt";
      open(my $testFileHandle, '>:encoding(UTF-8)', $testSourceFile)
         or die "Could not open file '$testSourceFile' $!";

      print $testFileHandle <<TESTEND;
# AMC-TXT source
PaperSize: A4
Lang: FR
Title: Mon premier questionnaire

Presentation: Veuillez répondre aux questions
ci-dessous du mieux que vous pouvez.

* Quelle est la capitale du Cameroun ?
+ Yaoundé
- Douala
- Kribi

** Parmi les nombres suivants,
lesquels sont positifs ?
+ 2
- -2
+ 10
TESTEND
   
      close($testFileHandle);
   }

   # ok just one txt #
   else {
    $testSourceFile = $txtFiles[0];
   }

   return $testSourceFile;
}

sub editTest {

   #------------------#
   # nothing to clean #
   #------------------#
   cleanActionFiles("$workingPath","edit-test");

   # get or build the TXT source #
   my $testTXTSourceFile = searchOrCreateTXTTest();
   
   # open it ! #
   print("When the test source is ready, launch the \"build-test\" action.\n");
   system("xdg-open $testTXTSourceFile");

}



########################
# ACTION : built-test  #
########################


################ big function : add student header to tex #############
sub addStudentHeader {

   my ($testBaseFile, $testTargetFile) = (@_);


   ####################
   # read source file #
   ####################
   open(my $testBaseFileHandle, '<:encoding(UTF-8)', $testBaseFile)
     or die "Could not open file '$testBaseFile' $!";

   #-------------#
   # read header #
   #-------------#

   # end string #
   my $searchString = '\begin{document}';

   # init search buffer #
   my $texHeader;
   my $searchBuffer;
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texHeader = $searchBuffer;

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texHeader .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         last;
      }
   }

   $texHeader = substr($texHeader, 0, -length($searchString));
   $texHeader .= "\n";


   #----------------#
   # read questions #
   #----------------#

   # previous chars #
   my $texQuestions = $searchString;

   # end string #
   $searchString = '\onecopy{.}{';

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texQuestions .= $searchBuffer;

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texQuestions .= $fileChar;
      if( $searchBuffer =~ m/\\onecopy\{.\}\{/ ) {
         last;
      }
   }

   $texQuestions = substr($texQuestions, 0, -length($searchString));
   $texQuestions .= "\n";


   #-------------------------#
   # read copy, before title #
   #-------------------------#
   my $searchCount = 0;
   my $braceCount = 1;

   # previous chars #
   my $texCopy = '\onecopy{1}{';

   # end string, we need second match #
   $searchString = '\begin{minipage}';

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texCopy .= $searchBuffer;

   my $openBraceCount = $searchBuffer =~ tr/\{//;
   my $closeBraceCount = $searchBuffer =~ tr/\}//;
   $braceCount += $openBraceCount;
   $braceCount -= $closeBraceCount; 

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # check brace #
      if( $fileChar eq '{' ) {
         $braceCount++;
      }

      if( $fileChar eq '}' ) {
         $braceCount--;
      }

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texCopy .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         $searchCount++;
         if( $searchCount == 2 ) {
            last;
         }
      }
   }

   $texCopy = substr($texCopy, 0, -length($searchString));
   $texCopy .= "\n";


   #---------------#
   # change title  #
   #---------------#

   # add new title #
   $texCopy .= <<LATEXTITLE;
\\begin\{center\}
   \\noindent\{\}\\fbox\{\\vspace*\{3mm\}
      \\Large\\bf\\displayname\{\}\\normalsize\{\}\% 
      \\vspace*\{3mm\}
   \}
\\end\{center\}
LATEXTITLE

   # pass old title #

   # end string #
  $searchString = '\end{minipage}';
  $searchCount = 0;

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {


      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         $searchCount++;
         if( $searchCount == 2 ) {
            last;
         }
      }
   }


   #---------------#
   # read copy end #
   #---------------#
   while(read $testBaseFileHandle, my $fileChar, 1) {

      $texCopy .= $fileChar;

      # check brace #
      if( $fileChar eq '{' ) {
         $braceCount++;
      }

      if( $fileChar eq '}' ) {
         $braceCount--;
      }

      if( $braceCount == 0 ) {
         last;
      }
   }


   # remove brace and add association #
   $texCopy = substr($texCopy, 0, -1);
   $texCopy .= "\\AMCassociation\{\\id\}\n\}\n";


   #-------------------#
   # read question end #
   #-------------------#

   # end string #
   $searchString = '\end{document}';

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texQuestions .= $searchBuffer;

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texQuestions .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         last;
      }
   }

   $texQuestions = substr($texQuestions, 0, -length($searchString));
   $texQuestions .= "\\csvreader\[head to column names\]\{inputlist.csv\}\{\}\{\\sujet\}\n\\end\{document\}\n";
   close($testBaseFileHandle);


   #################
   # create header #
   #################
   my $newTexHeader = '';

   foreach my $headerLine (split /\n/, $texHeader) {
      if( $headerLine =~ m/(automultiplechoice|documentclass)/ ) {
         $newTexHeader .= "$headerLine\n";
      }
   }

   $newTexHeader .= "\\usepackage{csvsimple}\n\n";


   ###############
   # create test #
   ###############
   my $newtest = '\newcommand{\sujet}{';
   $newtest .= "\n\n";
   $newtest .= $texCopy;
   $newtest .= "\n\}\n\n\n";

   ###################
   # build final tex #
   ###################

   # open file #
   open(my $testTargetFileHandle, '>:encoding(UTF-8)', $testTargetFile)
      or die "Could not open file '$testTargetFile' $!";

   # write header #
   print $testTargetFileHandle $newTexHeader;
   print $testTargetFileHandle $newtest;
   print $testTargetFileHandle $texQuestions;
   close($testTargetFileHandle);
}
################ end of big function : add student header to tex #############


sub buildTest {

   #-------#
   # clean #
   #-------#
   cleanActionFiles("$workingPath","build-test");

   # try to find student list #
   if( ! ensureSetStudents() ) {
      exit(0);
   }

   # try to find the TXT source #
   my $testTXTSourceFilePath = searchOrCreateTXTTest();
   print("Using TXT test source $testTXTSourceFilePath\n");


   # build the TEX from the TXT source #
   print("Builing base test tex file...   ");
   system("auto-multiple-choice prepare --with pdflatex --filter plain --filtered-source $workingPath/$amcPrivateDir/$baseTestTEXFileName --out-sujet $workingPath/$amcPrivateDir/$baseTestPDFFileName --out-corrige $workingPath/$amcPrivateDir/DOC-corrige.pdf --out-corrige-indiv $workingPath/$amcPrivateDir/DOC-indiv-solution.pdf --out-catalog $workingPath/$amcPrivateDir/DOC-catalog.pdf --out-calage $workingPath/$amcPrivateDir/DOC-calage.xy --mode s[sc]k --n-copies \"0\" $testTXTSourceFilePath --prefix $workingPath/$amcPrivateDir/ --latex-stdout --data $workingPath/$amcPrivateDir/data > /dev/null 2>&1");
   print("Done.\n");

   # keep only needed files #
   rename("$workingPath/$amcPrivateDir/$baseTestTEXFileName", "$workingPath/$amcPrivateDir/$baseTestTEXFileName.back");
   rename("$workingPath/$amcPrivateDir/$baseTestPDFFileName", "$workingPath/$amcPrivateDir/$baseTestPDFFileName.back");
   cleanActionFiles("$workingPath","build-test");
   rename("$workingPath/$amcPrivateDir/$baseTestTEXFileName.back", "$workingPath/$amcPrivateDir/$baseTestTEXFileName");
   rename("$workingPath/$amcPrivateDir/$baseTestPDFFileName.back", "$workingPath/$amcPrivateDir/$baseTestPDFFileName");

   # add header to tex #
   print("Adding students header to TEX file...   ");
   addStudentHeader("$workingPath/$amcPrivateDir/$baseTestTEXFileName", "$workingPath/$amcPrivateDir/$testTEXFileName");
   print("Done.\n");

   # build test #
   print("Building test...   ");
   system("auto-multiple-choice prepare --with pdflatex --filter latex --filtered-source $workingPath/$amcPrivateDir/subject_base.tex --out-sujet $workingPath/$amcPrivateDir/DOC-sujet.pdf --out-corrige $workingPath/$amcPrivateDir/DOC-corrige.pdf --out-corrige-indiv $workingPath/$amcPrivateDir/DOC-indiv-solution.pdf --out-catalog $workingPath/$amcPrivateDir/DOC-catalog.pdf --out-calage $workingPath/$amcPrivateDir/DOC-calage.xy --mode s[sc]k --n-copies \"0\" $workingPath/$amcPrivateDir/$testTEXFileName  --prefix $workingPath/$amcPrivateDir/ --latex-stdout --data $workingPath/$amcPrivateDir/data > /dev/null 2>&1");
   copy("$workingPath/$amcPrivateDir/DOC-sujet.pdf", "$workingPath/${testFileName}.pdf");
   print("Done.\n");

   # build layouts #
   print("Building layouts...   ");
   system("auto-multiple-choice meptex --src $workingPath/$amcPrivateDir/DOC-calage.xy --progression-id MEP --progression 1 --data $workingPath/$amcPrivateDir/data > /dev/null 2>&1");
   print("Done.\n");

   # prepare scan directory #
   if( ! -e "$workingPath/$scanDirectoryName" ) {
      mkdir("$workingPath/$scanDirectoryName");
   }
   print("Test has been built !\n");
   print("You can rebuild it as many times you want.\n"); 
   print("Now print : $workingPath/${testFileName}.pdf\n");
   print("And put scans in : $workingPath/$scanDirectoryName\n");
   print("Finally launch the \"read-copies\" action.\n"); 
   system("xdg-open $workingPath");
   system("xdg-open $workingPath/${testFileName}.pdf");
}

# ensure the build-test step was done #
sub ensureBuildTest {

   if( (! -e "$workingPath/$amcPrivateDir/data/layout.sqlite") ||
       (! -e "$workingPath/$amcPrivateDir/data/capture.sqlite") ) {
      print("You need to generate a test before !\n");
      print("Please create or edit a test source with the \"edit-test\" action\n");
      print("and build it with the \"build-test\" action\n");
      return;
   }

   return "true";
}


#########################
# ACTION : read-copies  #
#########################

sub readCopies {

   #-------#
   # clean #
   #-------#
   cleanActionFiles("$workingPath","read-copies"); 

   # check if the "set-students" and "build-test" steps was done #
   if( (! ensureSetStudents()) || (! ensureBuildTest()) ) {
      exit(0);
   } 

   # check if we have scans #
   my @scanFiles = glob("$workingPath/$scanDirectoryName/*");
   if( ! @scanFiles ) {
      print("Connot find copies scans in $workingPath/$scanDirectoryName\n");
      exit(0);
   }

   # generate scan files list #
   print("Generate scan files list...   ");
   open(my $scanFileListHandle, '>:encoding(UTF-8)', "$workingPath/$amcPrivateDir/$scanFilesListName")
      or die "Could not open file '$workingPath/$amcPrivateDir/$scanFilesListName' $!";

   foreach my $scanFile (@scanFiles) {
      print $scanFileListHandle "$scanFile\n";
   }
   print("Done.\n");

   # copy and prepare scan files #
   print("Preparing scans...   ");
   system("auto-multiple-choice read-pdfform --progression-id analyse --list $workingPath/$amcPrivateDir/$scanFilesListName --no-multiple --data $workingPath/$amcPrivateDir/data > /dev/null 2>&1");
   system("auto-multiple-choice getimages --progression-id analyse --list $workingPath/$amcPrivateDir/$scanFilesListName --vector-density 250 --copy-to $workingPath/$amcPrivateDir/scans/ --orientation portrait > /dev/null 2>&1");
   print("Done.\n");

   # analyse scans #
   print("Analysing scans...   ");
   system("auto-multiple-choice analyse --no-multiple --tol-marque 0.2,0.2 --prop 0.8 --bw-threshold 0.6 --progression-id analyse --progression 1 --n-procs \"0\" --data $workingPath/$amcPrivateDir/data --projet $workingPath/$amcPrivateDir/ --cr $workingPath/$amcPrivateDir/cr --liste-fichiers $workingPath/$amcPrivateDir/$scanFilesListName --no-ignore-red --try-three > /dev/null 2>&1");
   print("Done.\n");

   # correct copies #
   print("Correcting copies...   ");
   system("auto-multiple-choice prepare --out-corrige-indiv $workingPath/$amcPrivateDir/DOC-indiv-solution.pdf --n-copies \"0\" --with pdflatex --filter latex --filtered-source $workingPath/$amcPrivateDir/$baseTestTEXFileName --progression-id bareme --progression 1 --data $workingPath/$amcPrivateDir/data --mode bk $workingPath/$amcPrivateDir/$testTEXFileName > /dev/null 2>&1");
   system("auto-multiple-choice note --data $workingPath/$amcPrivateDir/data --seuil 0.15 --seuil-up 1 --grain 0.5 --arrondi inf --notemax 20 --plafond --notenull \"0\" --notemin \"\" --postcorrect-student \"\" --postcorrect-copy \"\" --no-postcorrect-set-multiple --progression-id notation --progression 1 > /dev/null 2>&1");
   print("Done.\n");

   # clean temporary files #
   print("Cleaning...   ");
   my @filteredScanFiles = glob("$workingPath/$amcPrivateDir/scans/*");
   foreach my $filteredScanFile (@filteredScanFiles) {
      unlink("$filteredScanFile");
   }

   my @amcCRFiles = glob("$workingPath/$amcPrivateDir/cr/*.jpg");
   foreach my $amcCRFile (@amcCRFiles) {
      unlink("$amcCRFile");
   }
   print("Done.\n");

   # associate students #
   print("Associating students...   ");
   system("auto-multiple-choice association-auto --data $workingPath/$amcPrivateDir/data --notes-id '<preassoc>' --liste $workingPath/$amcPrivateDir/$inputCSVFileName --liste-key id --csv-build-name '(name)' '(givenname)' --encodage-liste UTF-8 --pre-association > /dev/null 2>&1");
   print("Done.\n");

   # generate results #
   print("Generating results...   ");
   system("auto-multiple-choice export --module CSV --data $workingPath/$amcPrivateDir/data --useall  --sort n --fich-noms $workingPath/$amcPrivateDir/$inputCSVFileName --noms-encodage UTF-8 --csv-build-name '(name)' '(givenname)' --no-rtl --output $workingPath/$amcPrivateDir/exports/results.csv --option-out 'encodage=UTF-8' --option-out 'separateur=,' --option-out 'columns=student.copy,student.key,student.name' --option-out 'decimal=,' --option-out 'ticked=' > /dev/null 2>&1");
   print("Done.\n");

   #################
   # write results #
   #################

   # read the export #
   my $studentResults = csv(in => "$workingPath/$amcPrivateDir/exports/results.csv", headers => "auto");

   # open output #
   open(my $resultFileHandle, '>:encoding(UTF-8)', "$workingPath/$resultFileName")
      or die "Could not open file '$workingPath/$resultFileName' $!";

   # write result #
   foreach my $studentResult (@$studentResults) {
      print $resultFileHandle "$studentResult->{Name}${resultFileSeparator}$studentResult->{Mark}\n";
   }
   close($resultFileHandle);

   # print #
   print("Result generated in : $workingPath/$resultFileName\n");
   #print("Detailled result generated in : $workingPath/$detailledResultFileName");
   system("xdg-open $workingPath/$resultFileName");  

}

##################
# ACTION : clean #
##################
sub clean {
   print("Cleaning generated files...   ");
   cleanAllActionFiles($workingPath);
   print("Done.\n");
}


####################
# Launch : ACTIONS #
####################
if( "$action" eq "set-students" ) { setStudents(); }
elsif( "$action" eq "edit-test" ) { editTest(); }
elsif( "$action" eq "build-test" ) { buildTest(); }
elsif( "$action" eq "read-copies" ) { readCopies(); }
elsif( "$action" eq "clean" ) { clean(); }
elsif( "$action" eq "gui" ) { print("Launch Gui\n"); }
else {
   print("Unknown action : $action \n");
   usage();
}
