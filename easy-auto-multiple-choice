#! /usr/bin/perl -CS 
use strict;
use warnings;

# script encoding 
use utf8;

# stdout encoding #
#binmode(STDOUT, ":utf8");
# useless with -CS option #
use File::Spec;
use Cwd;
use Text::CSV qw( csv );; 
use Unicode::Normalize;
use File::Copy qw/ copy /;
use AMC::Data;
use AMC::DataModule::capture;

######################
# localized contants #
######################
my $defaultTestTXTFileName = "sujet";
my $testFileName = "sujet";
my $resultFileName = "resultats.csv";
my $detailledResultFileName = "resultats_complet.csv";
my $annotationFile = "annotations.pdf";
my $annotatedCopiesFile = "copies_corrigées.pdf";

my $resultFileSeparator = ";";
my $scanDirectoryName = "scans";
my $markSentence = "Note : ";
my $scoreSentence = "score : ";

# translations for "name", "firstname" or "group" #
# must be lower case and without accents #
my %studentCSVFieldsNames = ( "name" => "name",
                              "lastname" => "name",
                              "surname" => "name",
                              "students" => "name",
                              "nom" => "name",
                              "nom de famille" => "name",
                              "eleve" => "name",
                              "firstname" => "firstname",
                              "first name" => "firstname",
                              "givenname" => "firstname",
                              "given name" => "firstname",
                              "prenom" => "firstname",
                              "group" => "group",
                              "class" => "group",
                              "groupe" => "group",
                              "classe" => "group");

my $defaultTestContent = <<'TEST_END';
# CE FICHIER EST UN EXEMPLE DE SUJET DE QCM. C'EST À PARTIR
# DE CE FICHIER QU'EST GÉNÉRÉ LE SUJET AU FORMAT PDF A IMPRIMER.
#
# Si vous n'avez jamais utilisé "auto-multiple-choice" lisez
# les indications donnés dans cet exemple pour réaliser votre
# premier sujet de devoir en modifiant ce fichier.
#
# N'HÉSITEZ PAS À CLIQUER RÉGULIÈREMENT SUR "Générer le sujet"
# POUR VOIR LE SUJET FINAL ET COMPRENDRE LE RÔLE DE CHAQUE LIGNE.
# (Vous pouvez essayer dès maintenant !)
#
# La documentation complète d'auto-multiple-choice se trouve à cette adresse :
# https://www.auto-multiple-choice.net/auto-multiple-choice.fr/AMC-TXT.shtml


# COMMENTAIRES
#
# Toutes les lignes qui commence par un "#" ne sont pas prises
# en compte par le logiciel pour faire le sujet.
# C'est le cas de beaucoup de lignes de cet exemple qui ne
# contiennent que des explications.


################ 1 ) paramétrage du sujet ######################### 

# LA TAILLE DE PAPIER
# 
# En général on laissera cette option à "A4" 

PaperSize: A4


# LANGUE DU SUJET
#
# Vous pouvez changer la langue si votre sujet n'est pas en
# français en modifiant l'option "Lang:" ci-dessous.
# Par exemple mettez : "ES" pour espagnol, "DE" pour allemand
# ou "IT" pour Italien 

Lang: FR


# RECTO-VERSO
#
# Si vous ne souhaitez PAS imprimer votre sujet en recto-verso
# changez le "1" ci-dessous en "0". 

ManualDuplex: 1


# MÉLANGE DES QUESTIONS
#
# Si vous souhaitez que L'INTÉGRALITÉ des questions du devoir
# soient mélangées selon les élèves, changez le "0" ci-dessous
# en "1".
#
# Attention cela impose que votre sujet n'ai pas plusieurs
# parties distinctes puisque tout sera mélangé.
# Sinon il faut mélanger en utilisant les GROUPES de questions.
# (voir l'exemple à la fin de ce document).
#

ShuffleQuestions: 0
RandomSeed: 58548


# FORMULES MATHÉMATIQUES
#
# Si vous souhaitez mettre des formules mathématiques dans votre
# sujet changez le "0" ci-dessous en "1".
# Ensuite tapez les formules en Latex encadrées de "$".

LaTeX: 0


################ 2 ) l'entête du sujet #########################

# TITRE DU SUJET
#
# Vous pouvez saisir le titre du devoir après l'option "Title:"
# ci-dessous. 
# N'hésitez pas ensuite à cliquer sur "Générer le sujet" pour
# voir le résultat.  

Title: Mon premier devoir


# ÉNONCÉ GENERAL 
#
# Après "Présentation:" vous pouvez mettre l'énoncé global du
# sujet avec par exemple les consignes est la durée de l'épreuve.
#
# Vous pouvez aller à la ligne autant de fois que vous voulez.
# Cela n'ira pas à la ligne dans le sujet.
#
# Si vous voulez vraiment aller à la ligne dans le sujet. Il
# faut laisser une ligne vide comme dans l'exemple ci-dessous.
# (Cliquez sur "Générer le sujet" et observez les retours à la ligne)

Presentation: Vous avez une heure pour compléter les questions
suivantes. Pour répondre vous pouvez cocher ou noircir les cases. 

Les questions où plusieurs réponses sont possibles sont signalés
par un "Trèfle". ATTENTION ! Pour corriger une réponse fausse
passez l'intégralité de la case au correcteur et ne REDESSINEZ
PAS LA CASE.


################ 3 ) Les questions #########################

# EFFACEZ TOUTES LES QUESTIONS QUI SUIVENT SI VOUS SAVEZ
# DÉJÀ CRÉER VOS PROPRES QUESTIONS.
# (vous pouvez par contre garder les commentaires)


# QUESTION AVEC UNE SEULE BONNE RÉPONSE
#
# Pour créer une question avec une seule bonne réponse il
# suffit de commencer l'énoncé avec "*".
# Ensuite on met "+" Pour la bonne réponse et "-" pour les
# autres.

* Quelle est la capitale du Cameroun ?
+ Yaoundé
- Douala
- Kribi


# QUESTION AVEC PLUSIEURS RÉPONSES POTENTIELLES
#
# Si la question peut avoir aucune, une, ou plusieurs réponses
# correctes il faut commencer l'énoncé avec "**".
#
# Cela ajoute également automatiquement la réponse 
# "Aucune de ces réponses n’est correcte." 

** Parmi les nombres suivants, lesquels sont positifs ?
+ 2
- -2
+ 10


# RÉPONSES SUR UNE LIGNE
# 
# Pour gagner de la place lorsque les réponses sont courtes
# on peut ajouter "[horiz]" après le "*" ou le "**" pour 
# mettre les réponses sur une seule ligne.

*[horiz] Quelle est la capitale de la France ?
+ Paris
- Lille
- Ouagadougou


# ÉNONCÉ À PLUSIEURS LIGNES
#
# Il est possible d'écrire un enoncé à plusieurs lignes.
# Pour cela il faut comprendre qu'un retour à la ligne ici
# n'a pas d'effet. Par contre DEUX retours à la ligne 
# (ligne vide) créent un retour à la ligne dans le sujet.

*Vous connaissez sans doute le compositeur 
Frédéric Chopin. 

De quel pays est-il originaire ?
+ la Pologne
- le Vénézuela
- la Suisse


################ 4 ) Structurer l'énoncé #########################

# Le logiciel "auto-multiple-choice" a l'avantage de pouvoir mélanger 
# les questions et les réponses des questions pour éviter la copie.
#
# Si on veut mélanger TOUTES les questions du sujet, le plus simple
# est de mettre l'option "ShuffleQuestions:" à "1".
# (voir au début de ce document)
#
# Si le sujet comporte plusieurs parties et que l'on veut mélanger
# uniquement les questions à l'intérieur des parties, il faut alors
# utiliser les GROUPES de questions.


# CRÉATION D'UN GROUPE DE QUESTION
#
# On démarre un groupe de questions avec "*(" suivit
# de "[shuffle=true]" pour activer le mélange des questions.
#
# Et on termine le groupe avec :
#
# *)
#
# Si nécessaire, à l'intérieur, en plus des questions, on peut mettre
# un titre en l'encadrant des symboles "[==" et "==]", et/ou un énoncé
# pour le groupe.
# 
# On donne ci-dessous un exemple complet avec un titre, un énoncé, et
# trois questions qui seront mélangées selon les copies.
# (Vérifiez en générant le sujet, et en regardant l'ordre des questions
# pour trois élèves différents).

*([shuffle=true]

[==Martin Luther King==]

Les questions suivantes concernent Martin Luther King.

* En quelle année est-il né ?
- 1901
+ 1929
- 1968

* En quelle année est-il mort ?
- 1945
- 1515
+ 1968
- 1999

* Quelle est sa ville de naissance ?
+ Atlanta
- Memphis
- New York

*)

# SUITE DU SUJET
#
# Vous pouvez continuer d'ajouter ci-dessous vos questions ou vos groupes
# de questions.





TEST_END

##################################
# files generated by each action #
##################################
my $amcPrivateDir = "amc";
my $inputCSVFileName = "inputlist.csv";
my $baseTestTEXFileName = "test_base.tex";
my $baseTestPDFFileName = "test_base.pdf";
my $testTEXFileName = "test.tex";
my $scanFilesListName = "scan_files_list.txt";
my $testResultsFileName = "results.csv";

my %actionFiles = ( "gui"          => ["test"],
                    "set-students" => ["$amcPrivateDir/$inputCSVFileName"],
                    "edit-test"    => [],
                    "build-test"   => ["$amcPrivateDir/$baseTestTEXFileName",
                                       "$amcPrivateDir/$baseTestPDFFileName",
                                       "$amcPrivateDir/$testTEXFileName",
                                       "$amcPrivateDir/data/layout.sqlite",
                                       "$amcPrivateDir/DOC-sujet.pdf",
                                       "$amcPrivateDir/DOC-catalog.pdf",
                                       "$amcPrivateDir/DOC-calage.xy",
                                       "$amcPrivateDir/DOC-corrige.pdf",
                                       "$amcPrivateDir/DOC-indiv-solution.pdf",
                                       "$amcPrivateDir/amc-compiled.log",
                                       "$amcPrivateDir/amc-compiled.aux",
                                       "$amcPrivateDir/amc-compiled.amc",
                                       "$amcPrivateDir/amc-compiled.cs",
                                       "${testFileName}.pdf",
                                       "$amcPrivateDir/data/capture.sqlite"],
                    "read-copies"  => ["$amcPrivateDir/$scanFilesListName",
                                       "$amcPrivateDir/amc-compiled.xy",
                                       "$amcPrivateDir/amc-compiled.pdf",
                                       "$amcPrivateDir/data/scoring.sqlite",
                                       "$amcPrivateDir/data/association.sqlite",
                                       "$amcPrivateDir/exports/$testResultsFileName",
                                       "$resultFileName",
                                       "$detailledResultFileName",
                                       "$amcPrivateDir/data/report.sqlite",
                                       "$annotationFile",
                                       "$annotatedCopiesFile"],
                    "clean"        => [] ); 


sub cleanActionFiles {

   my ($projectPath,$action) = (@_);
   if( exists($actionFiles{$action}) ) {
      foreach my $actionFilePath (@{$actionFiles{$action}}) {
         if( -f "$projectPath/$actionFilePath" ) {
            unlink("$projectPath/$actionFilePath");
         }
      }
   }
}

sub cleanAllActionFiles {

   my ($projectPath) = (@_);
   foreach my $action (keys(%actionFiles)) {
      cleanActionFiles($projectPath, $action);
   }
}


sub createAmcBaseDirs {

   my $projectPath = $_[0];

   if( -d $projectPath ) {
      print("Creating base project files...   ");
      foreach my $dirPath ("$projectPath/$amcPrivateDir",
                           "$projectPath/$amcPrivateDir/cr",
                           "$projectPath/$amcPrivateDir/cr/corrections",
                           "$projectPath/$amcPrivateDir/cr/corrections/jpg",
                           "$projectPath/$amcPrivateDir/cr/corrections/pdf",
                           "$projectPath/$amcPrivateDir/cr/zooms",
                           "$projectPath/$amcPrivateDir/cr/diagnostic",
                           "$projectPath/$amcPrivateDir/data",
                           "$projectPath/$amcPrivateDir/scans",
                           "$projectPath/$amcPrivateDir/exports") {
         if( ! -e $dirPath ) {
            mkdir($dirPath);
         }
      }
      print("Done.\n");
   }
}


sub askYesOrNo {

   # get question from args #
   if( @_ != 1 ) {
      return;
   }

   my $question = $_[0];

   # ask the question #
   print("$question (y/n): ");
   while( 1 ) {
      my $reply = <STDIN>;
      if( $reply =~ m/^\s*y(es|)\s*$/i ) {
         return "y";
      }

      if( $reply =~ m/^\s*n(o|)\s*$/i ) {
         return "n";
      }

      print("Please, reply \"y\" or \"n\": ");  
   }
}


#############
# error log #
# for csv   #
#############
my $localErrorMessage = '';
my $localErrorCode = 0;
sub errorHandler {
   $localErrorMessage = $_[0];
   if( $localErrorMessage =~ m/ERROR: (\d{4})/ ) {
      $localErrorCode = scalar($1);
   } else {
      $localErrorCode = 0;
   }
}


########################
# string normalization #
########################
sub normalizeString {

   my $unicodeString = $_[0];
   chomp($unicodeString);

   # remove BOM #
   $unicodeString =~ s/^\x{FEFF}//;

   # remove special characters #
   $unicodeString = NFKD($unicodeString);
   $unicodeString =~ s/\p{NonspacingMark}//g;

   # trim and lowercase
   $unicodeString = lc($unicodeString);
   $unicodeString =~ s/^\s+|\s+$//g;

   return $unicodeString;
}



###################
# parse arguments #
###################
# get : 
# $workingPath
# $action

sub usage {
   my $binName = (File::Spec->splitpath($0))[2];
   print("usage : $binName <working_path> <action>\n");
   print("Possible actions are :\n");
   print("   gui          : launch the GUI\n");
   print("   set-students : read student list from CSV file\n");
   print("   edit-test    : launch the test editor\n");
   print("   build-test   : build a printable test\n");
   print("   read-copies  : read copies from scans\n");
   print("   clean        : clean all files except test source and student list\n");
   exit(0);
}    


# need just two arguments the path and the action #
if ( @ARGV !=  2 ) {
   usage();
}

# check path #
my $workingPath = $ARGV[0];
$workingPath = Cwd::realpath($workingPath);
if( ! -d $workingPath ) {

   # check parent #
   my $parentDir = (File::Spec->splitpath($workingPath))[1];
   if( -d $parentDir ) {

      # propose to create dir #
      if( askYesOrNo("The directory " . "$ARGV[0]" . " does not exist. Would you like to create it ?") eq "y" ) {
         mkdir($workingPath);
      } else {
         exit(0);
      }
   }

   else {
      print("Cannot find working directory : $workingPath\n");
      usage();
   }
}

# check action #
my $action = $ARGV[1];
if( ! exists($actionFiles{$action}) ) {
   print("Unknown action : $action \n");
   usage();
}

# init working dir #
createAmcBaseDirs($workingPath);


#########################
# ACTION : set-students #
#########################

sub getStudentCSVFiles {

   # search for a csv file witch is not the exam result #
   my @csvFiles = glob("$workingPath/*.csv");
   push(@csvFiles, glob("$workingPath/*.CSV"));
   @csvFiles = grep(!/($resultFileName|$detailledResultFileName)$/, @csvFiles);

   return @csvFiles;
}

sub setStudents {

   #-------#
   # clean #
   #-------#
   cleanActionFiles("$workingPath","set-students");

   # we need only one CSV file #
   my @csvFiles = getStudentCSVFiles();
    
   if( @csvFiles == 0 ) {
      print("No csv student list file found in the working directory !\n");
      print("Please ensure there is a csv file containing the list of students in :\n");
      print("$workingPath\n");
      exit(0);
   } 

   if( @csvFiles > 1 ) {
      print("Multiple csv files found for students list !\n");
      print("Please keep only the correct one and delete the others :\n");
      foreach my $csvFile (@csvFiles) {
         print("$csvFile\n");
      }
      exit(0);
   }

   my $studentsCSVPath = $csvFiles[0];


   #---------------------------#
   # try to parse the CSV file #
   #---------------------------#

   # create csv object #
   my $csv = Text::CSV->new({ binary => 1, auto_diag => 1});

   # open file #
   my $studentsCSVHandle;
   open($studentsCSVHandle, '<:encoding(UTF-8)', $studentsCSVPath)
      or die "Could not open file '$studentsCSVPath' $!";

   # read first line and try to determine CSV parameters #
   $SIG{__WARN__} = \&errorHandler;
   eval { $csv->header($studentsCSVHandle); };
   $SIG{__WARN__} = 'DEFAULT';


   # on error try to correct #
   if ( $@ ) {
      
      if( $localErrorCode == 1012 ) {

         # the header contain some empty fields, put some generic names #
         # ! this may be not a header line ! #
         my $studentsCSVSep = $csv->sep_char;

         seek($studentsCSVHandle, 0, 0);

         my $studentsCSVHeader = <$studentsCSVHandle>;
         my @studentsCSVHeaderNames = split(/$studentsCSVSep/,$studentsCSVHeader);
         
         my $headerIncrement = 0;
         my @modifiedHeader;
         foreach my $headerName (@studentsCSVHeaderNames) {
            if( $headerName ) {
               push @modifiedHeader, $headerName;
            } else {
               push @modifiedHeader, "generatedHeaderName" . $headerIncrement;
               $headerIncrement++;
            }
         }

         $csv = Text::CSV->new({ binary => 1, auto_diag => 1, sep_char => $studentsCSVSep });
         $csv->column_names(@modifiedHeader);
      }

      elsif( $localErrorCode == 1013 ) {

         # some headers are equal, may be no header line, the header is set later #
         my $studentsCSVSep = $csv->sep_char;
         $csv = Text::CSV->new({ binary => 1, auto_diag => 1, sep_char => $studentsCSVSep });
      }

      # unknown error #
      else {
         print("Error while parsing student CSV file !\n");
         print("$localErrorMessage\n");
         exit(0);
      }
   }

   #---------------------#
   # try to find headers #
   #---------------------#
   my $idColumnFound;
   
   # if we have headers check them #
   # ! this may be the first entry and not the header line ! #
   if( $csv->column_names ) {

      # translate header names #
      my @newHeaderNames;
      
      foreach my $headerName ($csv->column_names) {

         my $normalizedHeaderName = normalizeString($headerName);

         if( exists($studentCSVFieldsNames{$normalizedHeaderName}) ) {
            push @newHeaderNames, $studentCSVFieldsNames{$normalizedHeaderName};
            if( $studentCSVFieldsNames{$normalizedHeaderName} ne "group" ) { #name or firstname 
               $idColumnFound = "true";
            }
         } else {
            push @newHeaderNames, $headerName;
         }
      }

      $csv->column_names(@newHeaderNames);
   }


   # if we don't have correct header names, maybe this file have no header #
   # check a line #
   if( ! $idColumnFound ) {

      # go to beginning #
      seek($studentsCSVHandle, 0, 0);

      # get the first line #
      my $csvLine = <$studentsCSVHandle>;
      my @csvLineFields = split(/$csv->sep_char/,$csvLine);

      # assume one field is the complete name #
      if( @csvLineFields == 1 ) {
         $csv->column_names(["name"]);
      } 

      # assume two fields is name and firstname #
      # or firstname and name #  
      elsif( @csvLineFields == 2 ) {
         $csv->column_names(["name","firstname"]);
      } 

      # assume three fields is name, firstname and group #
      elsif( @csvLineFields == 3 ) {
         $csv->column_names(["name","firstname","group"]);
      }

      # cannot read CSV #
      else {
         print("Error while parsing students CSV file :\n");
         print("$studentsCSVPath\n");
         print("Please add headers to the CSV file\n");
         print("or keep only one or two fiedls for the student name.\n");
         exit(0);
      }

      # there is no header #
      seek($studentsCSVHandle, 0, 0);
   }

   # finish to parse #
   my $studentList = $csv->getline_hr_all($studentsCSVHandle);
   close($studentsCSVHandle);


   #-------------------------------------#
   # gererate the input list of students #
   # and display list of groups          #
   #-------------------------------------#
   my %studentGroups = ();

   # open file #
   open(my $inputCSVFileHandle, '>:encoding(UTF-8)', "$workingPath/$amcPrivateDir/$inputCSVFileName")
      or die "Could not open file '$workingPath/$amcPrivateDir/$inputCSVFileName' $!";

   # write header #
   print $inputCSVFileHandle "id,name,givenname,displayname,group\n";

   # write lines #
   my $currentId = 1; 
   foreach my $student (@$studentList) {

      # generate display name  #
      my $studentName = '';
      my $studentGivenName = '';
      my $studentDisplayName = '';
      my $studentGroup = '';

      if( exists($student->{name}) ) {
         $studentName = "$student->{name}";
         $studentDisplayName .= "$studentName ";
      }

      if( exists($student->{firstname}) ) {
         $studentGivenName = "$student->{firstname}";         
         $studentDisplayName .= "$studentGivenName ";
      }

      if( exists($student->{group}) ) {
         $studentGroup = "$student->{group}";
         $studentDisplayName .= "$studentGroup ";
      }
      $studentDisplayName =~ s/ $//;

      # add entry if not only spaces #
      if( ! ($studentDisplayName =~ /^ *$/) ) {
      
         # check group #
         if( exists($student->{group}) ) {
            if( ! exists($studentGroups{$studentGroup}) ) {
               $studentGroups{$studentGroup} = "true";
            }
         }

         print $inputCSVFileHandle "$currentId,$studentName,$studentGivenName,$studentDisplayName,$studentGroup\n";
         $currentId++;
      }
   }

   close($inputCSVFileHandle);
   $currentId--;

   # done #
   print("Found $currentId students in the csv file :\n");
   print("$studentsCSVPath\n");

   # if we have groups, display them #
   my @studentGroupList = keys(%studentGroups);
   if( @studentGroupList ) {
      print("From the following groups :\n");
      foreach my $group (@studentGroupList) {
         print("$group\n");
      }
      print("\n");
   }

   # next #
   print("You can now use the \"edit-test\" or \"build-test\" action\n");
   print("to create a test for these students.\n"); 
}


# ensure the set-student step was done #
sub ensureSetStudents {

   if( ! -f "$workingPath/$amcPrivateDir/$inputCSVFileName" ) {
      print("Please generate a student list before !\n");
      print("Put a csv file containing the list of students \n");
      print("in the working directory :\n");
      print("$workingPath\n");
      print("And launch the \"set-students\" actions.\n");
      return;
   }

   return "true";
}


#######################
# ACTION : edit-test  #
#######################

sub searchOrCreateTXTTest {

   my $testSourceFile;

   # try to find a txt file #
   my @txtFiles = glob("$workingPath/*.txt");
   push(@txtFiles, glob("$workingPath/*.TXT"));

   # if multiple found, warn #
   if( @txtFiles > 1 ) {
      print("Multiple TXT files found for test source !\n");
      print("Please keep only the correct one and delete the others :\n");
      foreach my $txtFile (@txtFiles) {
         print("$txtFile\n");
      }
      exit(0);
   }

   # if no txt file, generate one # 
   elsif( @txtFiles == 0 ) {

      print("No TXT test source, generating default ${defaultTestTXTFileName}.txt...   ");

      $testSourceFile = "$workingPath/${defaultTestTXTFileName}.txt";
      open(my $testFileHandle, '>:encoding(UTF-8)', $testSourceFile)
         or die "Could not open file '$testSourceFile' $!";

      print $testFileHandle $defaultTestContent;
      close($testFileHandle);
      print("Done.\n");
   }

   # ok just one txt #
   else {
    $testSourceFile = $txtFiles[0];
   }

   return $testSourceFile;
}

sub editTest {

   #------------------#
   # nothing to clean #
   #------------------#
   cleanActionFiles("$workingPath","edit-test");

   # get or build the TXT source #
   my $testTXTSourceFile = searchOrCreateTXTTest();
   
   # open it ! #
   print("When the test source is ready, launch the \"build-test\" action.\n");
   system("xdg-open $testTXTSourceFile");

}



########################
# ACTION : built-test  #
########################


################ big function : add student header to tex #############
sub addStudentHeader {

   my ($testBaseFile, $testTargetFile) = (@_);


   ####################
   # read source file #
   ####################
   open(my $testBaseFileHandle, '<:encoding(UTF-8)', $testBaseFile)
     or die "Could not open file '$testBaseFile' $!";

   #-------------#
   # read header #
   #-------------#

   # end string #
   my $searchString = '\begin{document}';

   # init search buffer #
   my $texHeader;
   my $searchBuffer;
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texHeader = $searchBuffer;

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texHeader .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         last;
      }
   }

   $texHeader = substr($texHeader, 0, -length($searchString));
   $texHeader .= "\n";


   #----------------#
   # read questions #
   #----------------#

   # previous chars #
   my $texQuestions = $searchString;

   # end string #
   $searchString = '\onecopy{.}{';

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texQuestions .= $searchBuffer;

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texQuestions .= $fileChar;
      if( $searchBuffer =~ m/\\onecopy\{.\}\{/ ) {
         last;
      }
   }

   $texQuestions = substr($texQuestions, 0, -length($searchString));
   $texQuestions .= "\n";


   #-------------------------#
   # read copy, before title #
   #-------------------------#
   my $searchCount = 0;
   my $braceCount = 1;

   # previous chars #
   my $texCopy = '\onecopy{1}{';

   # add id
   $texCopy .= "\n" . '\AMCassociation{\id}' . "\n";

   # end string, we need second match #
   $searchString = '\begin{minipage}';

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texCopy .= $searchBuffer;

   my $openBraceCount = $searchBuffer =~ tr/\{//;
   my $closeBraceCount = $searchBuffer =~ tr/\}//;
   $braceCount += $openBraceCount;
   $braceCount -= $closeBraceCount; 

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # check brace #
      if( $fileChar eq '{' ) {
         $braceCount++;
      }

      if( $fileChar eq '}' ) {
         $braceCount--;
      }

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texCopy .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         $searchCount++;
         if( $searchCount == 2 ) {
            last;
         }
      }
   }

   $texCopy = substr($texCopy, 0, -length($searchString));
   $texCopy .= "\n";


   #---------------#
   # change title  #
   #---------------#

   # add new title #
   $texCopy .= <<LATEXTITLE;
\\begin\{center\}
   \\noindent\{\}\\fbox\{\\vspace*\{3mm\}
      \\Large\\bf\\displayname\{\}\\normalsize\{\}\% 
      \\vspace*\{3mm\}
   \}
\\end\{center\}
LATEXTITLE

   # pass old title #

   # end string #
  $searchString = '\end{minipage}';
  $searchCount = 0;

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {


      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         $searchCount++;
         if( $searchCount == 2 ) {
            last;
         }
      }
   }


   #---------------#
   # read copy end #
   #---------------#
   while(read $testBaseFileHandle, my $fileChar, 1) {

      $texCopy .= $fileChar;

      # check brace #
      if( $fileChar eq '{' ) {
         $braceCount++;
      }

      if( $fileChar eq '}' ) {
         $braceCount--;
      }

      if( $braceCount == 0 ) {
         last;
      }
   }


   # remove brace and add association #
   # (now done at copy beginning ) 
   #$texCopy = substr($texCopy, 0, -1);
   #$texCopy .= "\\AMCassociation\{\\id\}\n\}\n";
   $texCopy .= "\n";

   #-------------------#
   # read question end #
   #-------------------#

   # end string #
   $searchString = '\end{document}';

   # init search buffer #
   read($testBaseFileHandle, $searchBuffer, length($searchString));
   $texQuestions .= $searchBuffer;

   # search #
   while(read $testBaseFileHandle, my $fileChar, 1) {

      # slide buffer #
      $searchBuffer = substr($searchBuffer, 1);
      $searchBuffer .= $fileChar;
      $texQuestions .= $fileChar;
      if( $searchBuffer eq $searchString ) {
         last;
      }
   }

   $texQuestions = substr($texQuestions, 0, -length($searchString));
   $texQuestions .= "\\csvreader\[head to column names\]\{inputlist.csv\}\{\}\{\\sujet\}\n\\end\{document\}\n";
   close($testBaseFileHandle);


   #################
   # create header #
   #################
   my $newTexHeader = '';

   foreach my $headerLine (split /\n/, $texHeader) {
      if( $headerLine =~ m/(automultiplechoice|documentclass)/ ) {
         $newTexHeader .= "$headerLine\n";
      }
   }

   $newTexHeader .= "\\usepackage{csvsimple}\n\n";


   ###############
   # create test #
   ###############
   my $newtest = '\newcommand{\sujet}{';
   $newtest .= "\n\n";
   $newtest .= $texCopy;
   $newtest .= "\n\}\n\n\n";

   ###################
   # build final tex #
   ###################

   # open file #
   open(my $testTargetFileHandle, '>:encoding(UTF-8)', $testTargetFile)
      or die "Could not open file '$testTargetFile' $!";

   # write header #
   print $testTargetFileHandle $newTexHeader;
   print $testTargetFileHandle $newtest;
   print $testTargetFileHandle $texQuestions;
   close($testTargetFileHandle);
}
################ end of big function : add student header to tex #############


sub buildTest {

   #-------#
   # clean #
   #-------#
   cleanActionFiles("$workingPath","build-test");

   # try to find student list #
   if( ! ensureSetStudents() ) {

      # if there is no CSV files, propose to create an example one #
      my @studentCSVFiles = getStudentCSVFiles();
      if( @studentCSVFiles == 0 ) {
         if( askYesOrNo("Would you like the to generate an example student list ?") eq "y" ) {

            # create an example student list #
            open(my $studentListFileHandle, '>:encoding(UTF-8)', "$workingPath/list.csv")
               or die "Could not open file '$workingPath/list.csv' $!";

            print $studentListFileHandle <<'CSV_END';
firstname,lastname
John,Doe
Alice,Bell
Barbara,Chamber
CSV_END

            close($studentListFileHandle);
            setStudents();
         }

         # no example student list, exit # 
         else {
            exit(0);
         }
      }

      # there is already some CSV files, exit #
      else {
         exit(0);
      }
   }

   # try to find the TXT source #
   my $testTXTSourceFilePath = searchOrCreateTXTTest();
   print("Using TXT test source $testTXTSourceFilePath\n");


   # build the TEX from the TXT source #
   print("Builing base test tex file...   ");
   system("auto-multiple-choice prepare --with pdflatex --filter plain --filtered-source '$workingPath/$amcPrivateDir/$baseTestTEXFileName' --out-sujet '$workingPath/$amcPrivateDir/$baseTestPDFFileName' --out-corrige '$workingPath/$amcPrivateDir/DOC-corrige.pdf' --out-corrige-indiv '$workingPath/$amcPrivateDir/DOC-indiv-solution.pdf' --out-catalog '$workingPath/$amcPrivateDir/DOC-catalog.pdf' --out-calage '$workingPath/$amcPrivateDir/DOC-calage.xy' --mode 's[sc]k' --n-copies \"0\" '$testTXTSourceFilePath' --prefix '$workingPath/$amcPrivateDir/' --latex-stdout --data '$workingPath/$amcPrivateDir/data' > /dev/null 2>&1");
   print("Done.\n");

   # keep only needed files #
   rename("$workingPath/$amcPrivateDir/$baseTestTEXFileName", "$workingPath/$amcPrivateDir/$baseTestTEXFileName.back");
   rename("$workingPath/$amcPrivateDir/$baseTestPDFFileName", "$workingPath/$amcPrivateDir/$baseTestPDFFileName.back");
   cleanActionFiles("$workingPath","build-test");
   rename("$workingPath/$amcPrivateDir/$baseTestTEXFileName.back", "$workingPath/$amcPrivateDir/$baseTestTEXFileName");
   rename("$workingPath/$amcPrivateDir/$baseTestPDFFileName.back", "$workingPath/$amcPrivateDir/$baseTestPDFFileName");

   # add header to tex #
   print("Adding students header to TEX file...   ");
   addStudentHeader("$workingPath/$amcPrivateDir/$baseTestTEXFileName", "$workingPath/$amcPrivateDir/$testTEXFileName");
   print("Done.\n");

   # build test #
   print("Building test...   ");
   system("auto-multiple-choice prepare --with pdflatex --filter latex --filtered-source '$workingPath/$amcPrivateDir/subject_base.tex' --out-sujet '$workingPath/$amcPrivateDir/DOC-sujet.pdf' --out-corrige '$workingPath/$amcPrivateDir/DOC-corrige.pdf' --out-corrige-indiv '$workingPath/$amcPrivateDir/DOC-indiv-solution.pdf' --out-catalog '$workingPath/$amcPrivateDir/DOC-catalog.pdf' --out-calage '$workingPath/$amcPrivateDir/DOC-calage.xy' --mode 's[sc]k' --n-copies \"0\" '$workingPath/$amcPrivateDir/$testTEXFileName'  --prefix '$workingPath/$amcPrivateDir/' --latex-stdout --data '$workingPath/$amcPrivateDir/data' > /dev/null 2>&1");
   copy("$workingPath/$amcPrivateDir/DOC-sujet.pdf", "$workingPath/${testFileName}.pdf");
   print("Done.\n");

   # build layouts #
   print("Building layouts...   ");
   system("auto-multiple-choice meptex --src '$workingPath/$amcPrivateDir/DOC-calage.xy' --progression-id MEP --progression 1 --data '$workingPath/$amcPrivateDir/data' > /dev/null 2>&1");
   print("Done.\n");

   # prepare scan directory #
   if( ! -e "$workingPath/$scanDirectoryName" ) {
      mkdir("$workingPath/$scanDirectoryName");
   }
   print("Test has been built !\n");
   print("You can rebuild it as many times you want.\n"); 
   print("Now print : $workingPath/${testFileName}.pdf\n");
   print("And put scans in : $workingPath/$scanDirectoryName\n");
   print("Finally launch the \"read-copies\" action.\n"); 
   system("xdg-open $workingPath");
   system("xdg-open $workingPath/${testFileName}.pdf");
}

# ensure the build-test step was done #
sub ensureBuildTest {

   if( (! -e "$workingPath/$amcPrivateDir/data/layout.sqlite") ||
       (! -e "$workingPath/$amcPrivateDir/data/capture.sqlite") ) {
      print("You need to generate a test before !\n");
      print("Please create or edit a test source with the \"edit-test\" action.\n");
      print("and build it with the \"build-test\" action.\n");
      return;
   }

   return "true";
}


#########################
# ACTION : read-copies  #
#########################

sub getScanOrderedStudentsIds {

   # open amc database #
   my $amcData = AMC::Data->new("$workingPath/$amcPrivateDir/data");
   my $amcCapture = $amcData->module('capture');

   # scan file <-> student id correspondancy #
   $amcData->begin_read_transaction('ALST');
   my @generatedScans = @{$amcCapture->dbh->selectall_arrayref("SELECT src,student FROM " . $amcCapture->table("page"))};
   $amcData->end_transaction('ALST');

   # get ordered scan list #
   my @orderedScanFiles;
   open(my $scanFileListHandle, '<:encoding(UTF-8)', "$workingPath/$amcPrivateDir/$scanFilesListName")
      or die "Could not open file '$workingPath/$amcPrivateDir/$scanFilesListName' $!";

   while( my $scanFilePath = <$scanFileListHandle> ) {
      chomp($scanFilePath);
      my $scanFile = (File::Spec->splitpath($scanFilePath))[2];
      push @orderedScanFiles, $scanFile;
   }
   close($scanFileListHandle);
   
   # generate ordered ids #
   my @scannedStudentCopieIDs;
   foreach my $scanFile (@orderedScanFiles) {

      # find the correponding id #
      my @scanFileStudents = grep { "$_->[0]" =~ m/${scanFile}$/ } @generatedScans;
      if( @scanFileStudents == 1 ) {
         my $newId = $scanFileStudents[0]->[1];
   
         # convert to four digits #
         my $idLength = 4 - length($newId);
         my $fourDigitsID = '';
         while( $idLength != 0 ) {
            $fourDigitsID .= "0";
            $idLength--;
         }
         $fourDigitsID .= "$newId";

         # add to the list if new #
         if( ! exists($scannedStudentCopieIDs[-1]) || ($scannedStudentCopieIDs[-1] ne $fourDigitsID) ) {
            push @scannedStudentCopieIDs, $fourDigitsID;
         }
      }
   }

   return @scannedStudentCopieIDs;
}

sub annotateScans {

   my $targetPDF = $_[0];

   # clean previous annotations if needed #
   my @annotationFiles = glob("$workingPath/$amcPrivateDir/cr/corrections/pdf/*");
   foreach my $annotationFile (@annotationFiles) {
      unlink("$annotationFile");
   }

   # annotate from scans #
   system("auto-multiple-choice annotate --cr '$workingPath/$amcPrivateDir/cr' --project '$workingPath/$amcPrivateDir/' --data '$workingPath/$amcPrivateDir/data' --subject '$workingPath/$amcPrivateDir/DOC-sujet.pdf' --corrected '$workingPath/$amcPrivateDir/DOC-indiv-solution.pdf' --filename-model '' --force-ascii --single-output ''  --sort l --id-file '' --progression-id annotate --progression 1 --line-width 2 --font-name 'Linux Libertine O 12' --symbols '0-0:none/#000000000000,0-1:circle/#ffff00000000,1-0:mark/#ffff00000000,1-1:box/#0000ffff0000' --no-indicatives --position 'marges' --dist-to-box '5.5' --n-digits '4' --verdict '%(ID)\n${markSentence}%s/%m (${scoreSentence}%S/%M)' --verdict-question '%s/%m' --verdict-question-cancelled 'X' --names-file '$workingPath/$amcPrivateDir/$inputCSVFileName' --names-encoding 'UTF-8' --csv-build-name '(name)' '(givenname)' --no-rtl --changes-only 1 --sort l --compose 1 --n-copies 0 --src '$workingPath/$amcPrivateDir/$testTEXFileName' --with pdflatex --filter latex --filtered-source '$workingPath/$amcPrivateDir/$baseTestTEXFileName' --embedded-max-size '1000x1500' --embedded-format jpeg --embedded-jpeg-quality 75 > /dev/null 2>&1");

   # get the scan ordered student list #
   my @scanOrderedStudentsIds = getScanOrderedStudentsIds();

   # find the corresponding files #
   my @scanOrderedStudentsAnnotatedFiles;
   foreach my $studentsId (@scanOrderedStudentsIds) {
      my @studentAnnotatedFiles = glob("$workingPath/$amcPrivateDir/cr/corrections/pdf/${studentsId}*");
      if( @studentAnnotatedFiles == 1 ) {
         push @scanOrderedStudentsAnnotatedFiles, $studentAnnotatedFiles[0];
      }
   }

   # generate arg #
   my $scanFilesListArg = '';
   foreach my $studentAnnotatedFile (@scanOrderedStudentsAnnotatedFiles) {
      $scanFilesListArg .= " '$studentAnnotatedFile'";
   }

   # concat to target files #
   system("pdftk $scanFilesListArg cat output '$targetPDF'");
}



sub readCopies {

   #-------#
   # clean #
   #-------#
   cleanActionFiles("$workingPath","read-copies"); 

   # check if the "set-students" and "build-test" steps was done #
   if( (! ensureSetStudents()) || (! ensureBuildTest()) ) {
      exit(0);
   } 

   # check if we have scans #
   my @scanFiles = glob("$workingPath/$scanDirectoryName/*");
   if( ! @scanFiles ) {
      print("Connot find copies scans in $workingPath/$scanDirectoryName\n");
      exit(0);
   }

   # generate scan files list #
   print("Generate scan files list...   ");
   open(my $scanFileListHandle, '>:encoding(UTF-8)', "$workingPath/$amcPrivateDir/$scanFilesListName")
      or die "Could not open file '$workingPath/$amcPrivateDir/$scanFilesListName' $!";

   foreach my $scanFile (@scanFiles) {
      print $scanFileListHandle "$scanFile\n";
   }
   close($scanFileListHandle);
   print("Done.\n");
   
   # copy and prepare scan files #
   print("Preparing scans...   ");
   system("auto-multiple-choice read-pdfform --progression-id analyse --list '$workingPath/$amcPrivateDir/$scanFilesListName' --no-multiple --data '$workingPath/$amcPrivateDir/data' > /dev/null 2>&1");
   system("auto-multiple-choice getimages --progression-id analyse --list '$workingPath/$amcPrivateDir/$scanFilesListName' --vector-density 250 --copy-to '$workingPath/$amcPrivateDir/scans/' --orientation portrait > /dev/null 2>&1");
   print("Done.\n");

   # analyse scans #
   print("Analysing scans...   ");
   system("auto-multiple-choice analyse --no-multiple --tol-marque '0.2,0.2' --prop 0.8 --bw-threshold 0.6 --progression-id analyse --progression 1 --n-procs \"0\" --data '$workingPath/$amcPrivateDir/data' --projet '$workingPath/$amcPrivateDir/' --cr '$workingPath/$amcPrivateDir/cr' --liste-fichiers '$workingPath/$amcPrivateDir/$scanFilesListName' --no-ignore-red --try-three > /dev/null 2>&1");
   print("Done.\n");

   # correct copies #
   print("Correcting copies...   ");
   system("auto-multiple-choice prepare --out-corrige-indiv '$workingPath/$amcPrivateDir/DOC-indiv-solution.pdf' --n-copies \"0\" --with pdflatex --filter latex --filtered-source '$workingPath/$amcPrivateDir/$baseTestTEXFileName' --progression-id bareme --progression 1 --data '$workingPath/$amcPrivateDir/data' --mode bk '$workingPath/$amcPrivateDir/$testTEXFileName' > /dev/null 2>&1");
   system("auto-multiple-choice note --data '$workingPath/$amcPrivateDir/data' --seuil 0.15 --seuil-up 1 --grain 0.5 --arrondi inf --notemax 20 --plafond --notenull \"0\" --notemin \"\" --postcorrect-student \"\" --postcorrect-copy \"\" --no-postcorrect-set-multiple --progression-id notation --progression 1 > /dev/null 2>&1");
   print("Done.\n");

   # associate students #
   print("Associating students...   ");
   system("auto-multiple-choice association-auto --data '$workingPath/$amcPrivateDir/data' --notes-id '<preassoc>' --liste '$workingPath/$amcPrivateDir/$inputCSVFileName' --liste-key id --csv-build-name '(name)' '(givenname)' --encodage-liste UTF-8 --pre-association > /dev/null 2>&1");
   print("Done.\n");

   # generate results #
   print("Generating results...   ");
   system("auto-multiple-choice export --module CSV --data '$workingPath/$amcPrivateDir/data' --useall  --sort n --fich-noms '$workingPath/$amcPrivateDir/$inputCSVFileName' --noms-encodage UTF-8 --csv-build-name '(name)' '(givenname)' --no-rtl --output '$workingPath/$amcPrivateDir/exports/results.csv' --option-out 'encodage=UTF-8' --option-out 'separateur=,' --option-out 'columns=student.copy,student.key,student.name' --option-out 'decimal=,' --option-out 'ticked=' > /dev/null 2>&1");
   print("Done.\n");


   #----------------------#
   # generate annotations #
   #----------------------#
   
   # create annotated copies #
   annotateScans("$workingPath/$annotatedCopiesFile");

   # convert all scans to blank #
   my @generatedScanFiles = glob("$workingPath/$amcPrivateDir/scans/*");
   foreach my $generatedScanFile (@generatedScanFiles) {
      system("mogrify -fill white -colorize '100,100,100' '$generatedScanFile'");
   }

   # create annotation file #
   annotateScans("$workingPath/$annotationFile");

   # clean temporary files #
   print("Cleaning...   ");
   my @temporaryFiles = glob("$workingPath/$amcPrivateDir/scans/*");
   push @temporaryFiles, glob("$workingPath/$amcPrivateDir/cr/*.jpg");
   push @temporaryFiles, glob("$workingPath/$amcPrivateDir/cr/corrections/pdf/*"); 

   foreach my $temporaryFile (@temporaryFiles) {
      unlink("$temporaryFile");
   }
   print("Done.\n");


   #################
   # write results #
   #################

   # read the export #
   my $studentResults = csv(in => "$workingPath/$amcPrivateDir/exports/results.csv", headers => "auto");

   # open output #
   open(my $resultFileHandle, '>:encoding(UTF-8)', "$workingPath/$resultFileName")
      or die "Could not open file '$workingPath/$resultFileName' $!";

   # write result #
   foreach my $studentResult (@$studentResults) {
      print $resultFileHandle "$studentResult->{Name}${resultFileSeparator}$studentResult->{Mark}\n";
   }
   close($resultFileHandle);

   # print #
   print("Result generated in : $workingPath/$resultFileName\n");
   #print("Detailled result generated in : $workingPath/$detailledResultFileName");
   system("xdg-open $workingPath/$resultFileName");  

}

##################
# ACTION : clean #
##################
sub clean {
   print("Cleaning generated files...   ");
   cleanAllActionFiles($workingPath);
   print("Done.\n");
}


####################
# Launch : ACTIONS #
####################
if( "$action" eq "set-students" ) { setStudents(); }
elsif( "$action" eq "edit-test" ) { editTest(); }
elsif( "$action" eq "build-test" ) { buildTest(); }
elsif( "$action" eq "read-copies" ) { readCopies(); }
elsif( "$action" eq "clean" ) { clean(); }
elsif( "$action" eq "gui" ) { print("Launch Gui\n"); }
else {
   print("Unknown action : $action \n");
   usage();
}
